<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Kana Quiz</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#0d0f14" />

  <!-- iOS meta tags -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Kana Quiz" />
  <link rel="apple-touch-icon" href="icon-192.png" />

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+JP:wght@400;700&display=swap"
    rel="stylesheet" />
  <script src="dictionary.js"></script>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #0d0f14;
      --surface: #161a23;
      --surface2: #1e2330;
      --border: #2c3347;
      --accent: #7c6fff;
      --accent2: #a78bfa;
      --green: #34d399;
      --red: #f87171;
      --text: #e8eaf0;
      --muted: #8892a4;
      --radius: 14px;
    }

    html,
    body {
      height: 100%;
      width: 100%;
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      -webkit-tap-highlight-color: transparent;
    }

    /* lock-scroll removed to fix mobile keyboard issues */

    #app {
      min-height: 100svh;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      position: relative;
    }

    /* centered removed to keep content at top, avoiding keyboard overlap */

    .screen {
      display: none;
      width: 100%;
      max-width: 480px;
    }

    .screen.active {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    header {
      text-align: center;
      padding: 12px 0 6px;
    }

    header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -.5px;
    }

    header p {
      font-size: .8rem;
      color: var(--muted);
      margin-top: 4px;
    }

    /* ‚îÄ‚îÄ Cards ‚îÄ‚îÄ */
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px;
    }

    /* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 14px 22px;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: opacity .15s, transform .1s;
      user-select: none;
      -webkit-user-select: none;
    }

    .btn:active {
      transform: scale(.97);
    }

    .btn:disabled {
      opacity: .35;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--accent);
      color: #fff;
      width: 100%;
    }

    .btn-outline {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      font-size: .85rem;
      padding: 8px 14px;
    }

    .btn-ghost {
      background: transparent;
      color: var(--muted);
      font-size: .8rem;
      padding: 6px 10px;
    }

    /* ‚îÄ‚îÄ Mode Toggle ‚îÄ‚îÄ */
    .mode-toggle {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
      background: var(--surface2);
      border-radius: 12px;
      padding: 4px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
    }

    .mode-toggle button {
      padding: 8px 4px;
      background: transparent;
      border: none;
      color: var(--muted);
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mode-toggle button.active {
      background: var(--surface);
      color: var(--text);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border);
    }

    /* ‚îÄ‚îÄ Selection screen ‚îÄ‚îÄ */
    .sel-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .group-block {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .group-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--surface2);
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }

    .group-header label {
      font-weight: 600;
      font-size: .9rem;
      cursor: pointer;
      flex: 1;
    }

    .group-header span {
      font-size: .75rem;
      color: var(--muted);
    }

    .group-entries {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 1px;
      background: var(--border);
    }

    .kana-entry {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      background: var(--surface);
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      transition: background .12s;
    }

    .kana-entry:hover {
      background: var(--surface2);
    }

    .kana-chars {
      display: flex;
      flex-direction: column;
      line-height: 1.3;
    }

    .kana-chars .hira {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 1.05rem;
    }

    .kana-chars .kata {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: .85rem;
      color: var(--muted);
    }

    .kana-roma {
      font-size: .78rem;
      color: var(--accent2);
      margin-left: auto;
    }

    /* custom checkbox */
    .kana-entry input[type=checkbox],
    .group-header input[type=checkbox] {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-radius: 5px;
      flex-shrink: 0;
      cursor: pointer;
      transition: background .15s, border-color .15s;
      position: relative;
    }

    .kana-entry input[type=checkbox]:checked,
    .group-header input[type=checkbox]:checked {
      background: var(--accent);
      border-color: var(--accent);
    }

    .kana-entry input[type=checkbox]:checked::after,
    .group-header input[type=checkbox]:checked::after {
      content: '';
      position: absolute;
      left: 3px;
      top: 0px;
      width: 6px;
      height: 10px;
      border: 2px solid #fff;
      border-top: none;
      border-left: none;
      transform: rotate(45deg);
    }

    .group-header input[type=checkbox]:indeterminate {
      background: var(--surface2);
      border-color: var(--accent);
    }

    .group-header input[type=checkbox]:indeterminate::after {
      content: '';
      position: absolute;
      left: 3px;
      top: 6px;
      width: 8px;
      height: 2px;
      background: var(--accent);
    }

    .sel-count {
      font-size: .85rem;
      color: var(--muted);
      text-align: center;
    }

    .sel-count strong {
      color: var(--text);
    }

    /* ‚îÄ‚îÄ Quiz screen ‚îÄ‚îÄ */
    .quiz-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: .82rem;
      color: var(--muted);
    }

    .quiz-meta>* {
      flex-shrink: 0;
    }

    .quiz-score {
      flex-shrink: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: 600;
      color: var(--text);
    }

    .kana-display {
      text-align: center;
      padding: 16px;
      position: relative;
      overflow: hidden;
    }

    .script-badge {
      display: inline-block;
      font-size: .72rem;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--accent2);
      background: rgba(124, 111, 255, .15);
      padding: 4px 10px;
      border-radius: 20px;
      margin-bottom: 14px;
    }

    .kana-char {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 5rem;
      line-height: 1;
      display: block;
      transition: opacity .15s, transform .15s;
      cursor: pointer;
    }

    .kana-char:active {
      opacity: 0.6;
      transform: scale(0.95);
    }

    .input-row {
      display: flex;
      gap: 10px;
    }

    #romaji-input {
      flex: 1;
      background: var(--surface2);
      border: 2px solid var(--border);
      border-radius: 12px;
      color: var(--text);
      font-size: 1.1rem;
      padding: 14px 16px;
      outline: none;
      transition: border-color .2s;
      font-family: 'Inter', sans-serif;
      -webkit-appearance: none;
      appearance: none;
    }

    #romaji-input:focus {
      border-color: var(--accent);
    }

    #romaji-input.correct {
      border-color: var(--green);
    }

    #romaji-input.wrong {
      border-color: var(--red);
    }

    #submit-btn {
      flex-shrink: 0;
      width: auto;
      padding: 14px 22px;
    }

    .easy-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      width: 100%;
    }

    .easy-btn {
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 0;
      font-size: 1.15rem;
      font-weight: 600;
      color: var(--text);
      cursor: pointer;
      transition: transform 0.1s, background 0.1s;
      user-select: none;
      -webkit-user-select: none;
    }

    .easy-btn.simple-btn {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 1.6rem;
    }

    .easy-btn:active {
      transform: scale(0.92);
    }

    /* ‚îÄ‚îÄ Drawing Area ‚îÄ‚îÄ */
    .draw-area {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    #draw-canvas {
      background: var(--surface2);
      border: 2px solid var(--border);
      border-radius: 12px;
      cursor: crosshair;
      touch-action: none;
    }

    .draw-controls {
      display: flex;
      gap: 10px;
      width: 100%;
      max-width: 280px;
      margin: 0 auto;
    }

    .draw-controls .btn {
      flex: 1;
    }

    .self-grade {
      display: none;
      width: 100%;
      max-width: 280px;
      margin: 0 auto;
      display: flex;
      gap: 10px;
    }

    .self-grade .btn {
      flex: 1;
    }

    .btn-correct {
      background: rgba(52, 211, 153, .15);
      color: var(--green);
      border: 1px solid var(--green);
    }

    .btn-wrong {
      background: rgba(248, 113, 113, .15);
      color: var(--red);
      border: 1px solid var(--red);
    }

    .easy-btn.correct {
      background: rgba(52, 211, 153, .2);
      border-color: var(--green);
      color: var(--green);
    }

    .easy-btn.wrong {
      background: rgba(248, 113, 113, .2);
      border-color: var(--red);
      color: var(--red);
    }

    .easy-btn:disabled {
      opacity: 0.8;
      cursor: not-allowed;
    }

    /* Feedback container under input */
    .feedback {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      margin-top: 12px;
      min-height: 50px;
      pointer-events: none;
      background: transparent;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .feedback.active {
      opacity: 1;
    }

    .feedback-bubble {
      padding: 18px 32px;
      border-radius: 20px;
      font-size: 1.4rem;
      font-weight: 700;
      opacity: 0;
      transform: scale(.85);
      transition: opacity .18s, transform .18s;
      text-align: center;
    }

    .feedback-bubble.show {
      opacity: 1;
      transform: scale(1);
    }

    .feedback-bubble.ok {
      background: rgba(52, 211, 153, .2);
      color: var(--green);
      border: 1px solid var(--green);
    }

    .feedback-bubble.bad {
      background: rgba(248, 113, 113, .2);
      color: var(--red);
      border: 1px solid var(--red);
    }

    /* ‚îÄ‚îÄ Summary screen ‚îÄ‚îÄ */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .stat-box {
      background: var(--surface2);
      border-radius: 10px;
      padding: 12px 14px;
      text-align: center;
    }

    .stat-box .val {
      font-size: 1.8rem;
      font-weight: 700;
      line-height: 1;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-box .lbl {
      font-size: .72rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .stat-box.full {
      grid-column: 1 / -1;
    }

    .mistakes-title {
      font-size: .9rem;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .mistakes-table {
      width: 100%;
      border-collapse: collapse;
      font-size: .82rem;
    }

    .mistakes-table th {
      text-align: left;
      color: var(--muted);
      font-weight: 500;
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
    }

    .mistakes-table td {
      padding: 7px 8px;
      border-bottom: 1px solid var(--border);
      font-family: 'Noto Sans JP', sans-serif;
    }

    .mistakes-table td.roma {
      font-family: 'Inter', sans-serif;
      color: var(--accent2);
    }

    .mistakes-table td.errs {
      font-family: 'Inter', sans-serif;
      color: var(--red);
      font-weight: 600;
      text-align: right;
    }

    .memo-bar {
      height: 8px;
      background: var(--surface2);
      border-radius: 99px;
      overflow: hidden;
      margin-top: 8px;
    }

    .memo-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--green));
      border-radius: 99px;
      transition: width .6s ease;
    }

    .memo-label {
      font-size: .78rem;
      color: var(--muted);
      margin-top: 6px;
    }

    .memo-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
    }

    .memo-tag {
      background: var(--surface2);
      border: 1px solid var(--accent);
      color: var(--text);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.85rem;
      font-family: 'Noto Sans JP', sans-serif;
    }

    .summary-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* ‚îÄ‚îÄ Misc ‚îÄ‚îÄ */
    .divider {
      height: 1px;
      background: var(--border);
    }

    a {
      color: var(--accent2);
      text-decoration: none;
    }

    .footer {
      margin-top: auto;
      padding-top: 30px;
      text-align: center;
      font-size: 0.7rem;
      color: var(--muted);
      opacity: 0.6;
    }

    @media (prefers-color-scheme: light) {
      /* stays dark ‚Äî intentional */
    }

    @keyframes drawStrokeAnim {
      0% {
        stroke-dashoffset: 350;
      }

      100% {
        stroke-dashoffset: 0;
      }
    }

    .stroke-anim {
      stroke-dasharray: 350;
      stroke-dashoffset: 350;
      animation: drawStrokeAnim 1.0s ease-in-out forwards;
    }

    /* ‚îÄ‚îÄ‚îÄ Progress Dashboard ‚îÄ‚îÄ‚îÄ */
    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 14px;
    }

    .kana-mastery-group {
      margin-bottom: 18px;
    }

    .kana-mastery-group h3 {
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }

    .kana-mastery-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .kana-mastery-cell {
      width: 44px;
      height: 44px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      font-family: 'Noto Sans JP', sans-serif;
      font-weight: bold;
      cursor: default;
      border: 1px solid transparent;
      transition: transform 0.15s;
    }

    .kana-mastery-cell sub {
      font-size: 0.48rem;
      font-family: 'Inter', sans-serif;
      font-weight: 400;
      color: inherit;
      opacity: 0.7;
      margin-top: -3px;
    }

    .mastery-0 {
      background: var(--surface2);
      color: var(--muted);
      border-color: var(--border);
    }

    .mastery-1 {
      background: #4a2020;
      color: #ff8888;
      border-color: #aa4444;
    }

    .mastery-2 {
      background: #3a3a10;
      color: #ddcc44;
      border-color: #887722;
    }

    .mastery-3 {
      background: #123a14;
      color: #66ee77;
      border-color: #338844;
    }

    .progress-legend {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 14px;
      font-size: 0.72rem;
    }

    .legend-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 3px;
      margin-right: 4px;
    }
  </style>
</head>

<body>
  <div id="app">

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SELECTION SCREEN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div id="screen-select" class="screen active">
      <header style="position: relative;">
        <button id="btn-lang" onclick="toggleLang()"
          style="position: absolute; top: 0; right: 0; padding: 6px 12px; font-size: 0.75rem; border-radius: 20px; background: var(--surface2); border: 1px solid var(--border); color: var(--text); cursor: pointer;">EN</button>
        <h1>„Åã„Å™ Quiz</h1>
        <p data-i18n="sel_subtitle">Select the kana you want to practice</p>
      </header>

      <div class="mode-toggle">
        <button id="mode-normal" class="active" style="font-size: 0.65rem;"
          data-i18n="mode_type_kr">Type<br>(Kana‚ÜíR)</button>
        <button id="mode-easy" style="font-size: 0.65rem;" data-i18n="mode_sel_kr">Select<br>(Kana‚ÜíR)</button>
        <button id="mode-easy-kk" style="font-size: 0.65rem;" data-i18n="mode_sel_hk">Select<br>(H‚ÜîK)</button>
        <button id="mode-audio-select" style="font-size: 0.65rem;" data-i18n="mode_sel_ak">Select<br>(üîä‚ÜíKana)</button>
        <button id="mode-simple" style="font-size: 0.65rem;" data-i18n="mode_sel_rk">Select<br>(R‚ÜíKana)</button>
        <button id="mode-read-word" style="font-size: 0.65rem;" data-i18n="mode_read_word">Read Word<br>(Type
          Romaji)</button>
        <button id="mode-draw" style="font-size: 0.65rem;" data-i18n="mode_draw_rk">Draw<br>(R‚ÜíKana)</button>
        <button id="mode-draw-kk" style="font-size: 0.65rem;" data-i18n="mode_draw_hk">Draw<br>(H‚ÜîK)</button>
        <button id="mode-audio-draw" style="font-size: 0.65rem;" data-i18n="mode_draw_ak">Draw<br>(üîä‚ÜíKana)</button>
      </div>

      <div class="sel-controls" style="display: flex; align-items: center; flex-wrap: wrap; gap: 15px;">
        <label
          style="color: var(--text); font-size: 0.9rem; display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="cb-sprint" style="cursor: pointer;"> <span data-i18n="sel_sprint">Timed Sprint
            (60s)</span>
        </label>
        <label
          style="color: var(--text); font-size: 0.9rem; display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="cb-practice" style="cursor: pointer;"> <span data-i18n="sel_practice">Practice Mode
            (No Stats)</span>
        </label>
        <div style="display: flex; align-items: center; gap: 8px;">
          <label for="sel-char-mode" style="color: var(--text); font-size: 0.9rem;" data-i18n="sel_char_mode">Character
            Mode:</label>
          <select id="sel-char-mode" disabled
            style="background: var(--surface2); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 4px 8px; font-size: 0.85rem; outline: none;">
            <option value="all" data-i18n="opt_all">All</option>
            <option value="h" data-i18n="opt_hiragana_only">Hiragana Only</option>
            <option value="k" data-i18n="opt_katakana_only">Katakana Only</option>
          </select>
        </div>
      </div>

      <div class="sel-controls" style="flex-wrap: wrap; gap: 6px;">
        <button class="btn btn-outline" id="btn-all" data-i18n="sel_all">Select All</button>
        <button class="btn btn-outline" id="btn-none" data-i18n="sel_none">Deselect All</button>
        <button class="btn btn-outline" id="btn-review-weak" data-i18n="sel_review"
          style="color: #5eead4; border-color: #5eead4;">Review Weaknesses</button>
        <button class="btn btn-outline" id="btn-progress" data-i18n="sel_progress"
          style="color: #38bdf8; border-color: #38bdf8;">Progress</button>
        <button class="btn btn-outline" id="btn-reset-stats" data-i18n="sel_reset"
          style="color: var(--accent1); border-color: var(--accent1);">Reset Stats</button>
      </div>

      <div id="group-list"><!-- rendered by JS --></div>

      <p class="sel-count" id="sel-count" style="margin-top: 10px;">0 entries selected</p>
      <button class="btn btn-primary" id="btn-start" disabled data-i18n="sel_start">Start Quiz</button>

      <footer class="footer">
        <p>&copy; 2026 Dave Wang | Version: 20260227-2212</p>
      </footer>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê QUIZ SCREEN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div id="screen-quiz" class="screen">
      <header>
        <h1>„Åã„Å™ Quiz</h1>
      </header>

      <div class="quiz-meta" style="align-items: center;">
        <span id="q-progress">Q 1</span>
        <span class="quiz-score" id="q-score">‚úì 0 &nbsp; ‚úó 0</span>
        <span id="q-timer" style="display:none; color: var(--accent1); font-weight: bold;"></span>
        <button class="btn btn-ghost" id="btn-end" style="margin-left: auto;" data-i18n="quiz_end">End</button>
      </div>

      <div class="card kana-display">
        <span class="script-badge" id="script-label">Hiragana</span>
        <div id="audio-btn-container"
          style="display: none; align-items: center; justify-content: center; margin-bottom: 10px; margin-top: -10px;">
          <button class="btn btn-primary" id="btn-replay-audio"
            style="border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; display: flex; align-items: center; justify-content: center;">üîä</button>
        </div>
        <span class="kana-char" id="kana-char">„ÅÇ</span>
      </div>

      <div class="input-row" id="input-row">
        <input id="romaji-input" type="text" autocomplete="off" autocorrect="off" autocapitalize="none"
          spellcheck="false" placeholder="romaji‚Ä¶" />
        <button class="btn btn-primary" id="submit-btn">‚Üí</button>
      </div>

      <div class="easy-grid" id="easy-grid" style="display:none;"></div>

      <div class="draw-area" id="draw-area" style="display:none;">
        <canvas id="draw-canvas" width="280" height="280"></canvas>
        <div class="draw-controls" id="draw-submit-area">
          <button class="btn btn-outline" id="btn-draw-clear" data-i18n="draw_clear">Clear</button>
          <button class="btn btn-primary" id="btn-draw-show" data-i18n="draw_show">Show Answer</button>
        </div>
        <div class="self-grade" id="self-grade" style="display:none;">
          <button class="btn btn-wrong" id="btn-self-wrong" data-i18n="draw_wrong">Incorrect</button>
          <button class="btn btn-correct" id="btn-self-correct" data-i18n="draw_correct">Correct</button>
        </div>
      </div>

      <div class="feedback" id="feedback">
        <div class="feedback-bubble" id="feedback-bubble"></div>
      </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SUMMARY SCREEN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div id="screen-summary" class="screen">
      <header>
        <h1 data-i18n="sum_title">Session Summary</h1>
        <p id="sum-date"></p>
      </header>

      <div class="stats-grid" id="stats-grid"><!-- filled by JS --></div>

      <div class="card" id="memo-card">
        <div class="memo-label" id="memo-label">Memorized 0 / 0 entries</div>
        <div class="memo-bar">
          <div class="memo-bar-fill" id="memo-fill" style="width:0%"></div>
        </div>
        <div class="memo-label" style="margin-top:8px;font-size:.72rem" data-i18n="sum_memo_rule">
          Rule: ‚â• 3 shown &amp; all correct for both hiragana and katakana
        </div>
        <div id="memo-results" style="display:none; margin-top: 15px;">
          <p class="mistakes-title" data-i18n="sum_newly_mem">Newly Memorized Characters</p>
          <div class="memo-list" id="memo-list"></div>
        </div>
      </div>

      <div id="mistakes-section" style="display:none;">
        <div class="card">
          <p class="mistakes-title" data-i18n="sum_got_wrong">Characters you got wrong</p>
          <table class="mistakes-table">
            <thead>
              <tr>
                <th data-i18n="lbl_hiragana">Hiragana</th>
                <th data-i18n="lbl_katakana">Katakana</th>
                <th data-i18n="th_romaji">Romaji</th>
                <th data-i18n="th_script">Script</th>
                <th style="text-align:right" data-i18n="th_errors">Errors</th>
              </tr>
            </thead>
            <tbody id="mistakes-tbody"></tbody>
          </table>
        </div>
      </div>

      <div class="summary-actions">
        <button class="btn btn-primary" id="btn-retry" data-i18n="sum_retry">Practice Again</button>
        <button class="btn btn-outline" id="btn-reselect" data-i18n="sum_reselect">Change Selection</button>
      </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PROGRESS DASHBOARD ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div id="screen-progress" class="screen" style="padding: 20px 0;">
      <div class="progress-header">
        <h2 style="margin: 0;" data-i18n="prog_title">Progress</h2>
        <button class="btn btn-ghost" id="btn-progress-back" data-i18n="prog_back">&larr; Back</button>
      </div>
      <div class="progress-legend">
        <span><span class="legend-dot" style="background:#4a2020; border:1px solid #aa4444;"></span><span
            data-i18n="prog_struggling">Struggling</span></span>
        <span><span class="legend-dot" style="background:#3a3a10; border:1px solid #ddcc44;"></span><span
            data-i18n="prog_inprogress">In Progress</span></span>
        <span><span class="legend-dot" style="background:#123a14; border:1px solid #338844;"></span><span
            data-i18n="prog_memorized">Memorized</span></span>
        <span><span class="legend-dot" style="background:var(--surface2); border:1px solid var(--border);"></span><span
            data-i18n="prog_unseen">Unseen</span></span>
      </div>
      <div id="progress-content"><!-- filled by JS --></div>
    </div>

  </div>

  <!-- Feedback overlay moved inside kana-display -->

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  KANA DATA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const KANA_GROUPS = [
      {
        name: "Vowels", nameKey: "grp_vowels", entries: [
          { h: "„ÅÇ", k: "„Ç¢", r: "a" }, { h: "„ÅÑ", k: "„Ç§", r: "i" },
          { h: "„ÅÜ", k: "„Ç¶", r: "u" }, { h: "„Åà", k: "„Ç®", r: "e" },
          { h: "„Åä", k: "„Ç™", r: "o" },
        ]
      },
      {
        name: "K row", nameKey: "grp_k", entries: [
          { h: "„Åã", k: "„Ç´", r: "ka" }, { h: "„Åç", k: "„Ç≠", r: "ki" },
          { h: "„Åè", k: "„ÇØ", r: "ku" }, { h: "„Åë", k: "„Ç±", r: "ke" },
          { h: "„Åì", k: "„Ç≥", r: "ko" },
        ]
      },
      {
        name: "S row", nameKey: "grp_s", entries: [
          { h: "„Åï", k: "„Çµ", r: "sa" }, { h: "„Åó", k: "„Ç∑", r: "shi", alt: ["si"] },
          { h: "„Åô", k: "„Çπ", r: "su" }, { h: "„Åõ", k: "„Çª", r: "se" },
          { h: "„Åù", k: "„ÇΩ", r: "so" },
        ]
      },
      {
        name: "T row", nameKey: "grp_t", entries: [
          { h: "„Åü", k: "„Çø", r: "ta" }, { h: "„Å°", k: "„ÉÅ", r: "chi", alt: ["ti"] },
          { h: "„Å§", k: "„ÉÑ", r: "tsu", alt: ["tu"] }, { h: "„Å¶", k: "„ÉÜ", r: "te" },
          { h: "„Å®", k: "„Éà", r: "to" },
        ]
      },
      {
        name: "N row", nameKey: "grp_n", entries: [
          { h: "„Å™", k: "„Éä", r: "na" }, { h: "„Å´", k: "„Éã", r: "ni" },
          { h: "„Å¨", k: "„Éå", r: "nu" }, { h: "„Å≠", k: "„Éç", r: "ne" },
          { h: "„ÅÆ", k: "„Éé", r: "no" },
        ]
      },
      {
        name: "H row", nameKey: "grp_h", entries: [
          { h: "„ÅØ", k: "„Éè", r: "ha" }, { h: "„Å≤", k: "„Éí", r: "hi" },
          { h: "„Åµ", k: "„Éï", r: "fu", alt: ["hu"] }, { h: "„Å∏", k: "„Éò", r: "he" },
          { h: "„Åª", k: "„Éõ", r: "ho" },
        ]
      },
      {
        name: "M row", nameKey: "grp_m", entries: [
          { h: "„Åæ", k: "„Éû", r: "ma" }, { h: "„Åø", k: "„Éü", r: "mi" },
          { h: "„ÇÄ", k: "„É†", r: "mu" }, { h: "„ÇÅ", k: "„É°", r: "me" },
          { h: "„ÇÇ", k: "„É¢", r: "mo" },
        ]
      },
      {
        name: "Y row", nameKey: "grp_y", entries: [
          { h: "„ÇÑ", k: "„É§", r: "ya" }, { h: "„ÇÜ", k: "„É¶", r: "yu" },
          { h: "„Çà", k: "„É®", r: "yo" },
        ]
      },
      {
        name: "R row", nameKey: "grp_r", entries: [
          { h: "„Çâ", k: "„É©", r: "ra" }, { h: "„Çä", k: "„É™", r: "ri" },
          { h: "„Çã", k: "„É´", r: "ru" }, { h: "„Çå", k: "„É¨", r: "re" },
          { h: "„Çç", k: "„É≠", r: "ro" },
        ]
      },
      {
        name: "W row / N", nameKey: "grp_w", entries: [
          { h: "„Çè", k: "„ÉØ", r: "wa" }, { h: "„Çí", k: "„É≤", r: "wo" },
          { h: "„Çì", k: "„É≥", r: "n" },
        ]
      },
      {
        name: "G row (voiced)", nameKey: "grp_g", entries: [
          { h: "„Åå", k: "„Ç¨", r: "ga" }, { h: "„Åé", k: "„ÇÆ", r: "gi" },
          { h: "„Åê", k: "„Ç∞", r: "gu" }, { h: "„Åí", k: "„Ç≤", r: "ge" },
          { h: "„Åî", k: "„Ç¥", r: "go" },
        ]
      },
      {
        name: "Z row (voiced)", nameKey: "grp_z", entries: [
          { h: "„Åñ", k: "„Ç∂", r: "za" }, { h: "„Åò", k: "„Ç∏", r: "ji", alt: ["zi"] },
          { h: "„Åö", k: "„Ç∫", r: "zu" }, { h: "„Åú", k: "„Çº", r: "ze" },
          { h: "„Åû", k: "„Çæ", r: "zo" },
        ]
      },
      {
        name: "D row (voiced)", nameKey: "grp_d", entries: [
          { h: "„Å†", k: "„ÉÄ", r: "da" }, { h: "„Å¢", k: "„ÉÇ", r: "ji" },
          { h: "„Å•", k: "„ÉÖ", r: "zu" }, { h: "„Åß", k: "„Éá", r: "de" },
          { h: "„Å©", k: "„Éâ", r: "do" },
        ]
      },
      {
        name: "B row (voiced)", nameKey: "grp_b", entries: [
          { h: "„Å∞", k: "„Éê", r: "ba" }, { h: "„Å≥", k: "„Éì", r: "bi" },
          { h: "„Å∂", k: "„Éñ", r: "bu" }, { h: "„Åπ", k: "„Éô", r: "be" },
          { h: "„Åº", k: "„Éú", r: "bo" },
        ]
      },
      {
        name: "P row (semi-voiced)", nameKey: "grp_p", entries: [
          { h: "„Å±", k: "„Éë", r: "pa" }, { h: "„Å¥", k: "„Éî", r: "pi" },
          { h: "„Å∑", k: "„Éó", r: "pu" }, { h: "„Å∫", k: "„Éö", r: "pe" },
          { h: "„ÅΩ", k: "„Éù", r: "po" },
        ]
      },
      {
        name: "Contracted (K, S, T, N)", nameKey: "grp_con1", entries: [
          { h: "„Åç„ÇÉ", k: "„Ç≠„É£", r: "kya" }, { h: "„Åç„ÇÖ", k: "„Ç≠„É•", r: "kyu" }, { h: "„Åç„Çá", k: "„Ç≠„Éß", r: "kyo" },
          { h: "„Åó„ÇÉ", k: "„Ç∑„É£", r: "sha", alt: ["sya"] }, { h: "„Åó„ÇÖ", k: "„Ç∑„É•", r: "shu", alt: ["syu"] }, { h: "„Åó„Çá", k: "„Ç∑„Éß", r: "sho", alt: ["syo"] },
          { h: "„Å°„ÇÉ", k: "„ÉÅ„É£", r: "cha", alt: ["tya"] }, { h: "„Å°„ÇÖ", k: "„ÉÅ„É•", r: "chu", alt: ["tyu"] }, { h: "„Å°„Çá", k: "„ÉÅ„Éß", r: "cho", alt: ["tyo"] },
          { h: "„Å´„ÇÉ", k: "„Éã„É£", r: "nya" }, { h: "„Å´„ÇÖ", k: "„Éã„É•", r: "nyu" }, { h: "„Å´„Çá", k: "„Éã„Éß", r: "nyo" }
        ]
      },
      {
        name: "Contracted (H, M, R)", nameKey: "grp_con2", entries: [
          { h: "„Å≤„ÇÉ", k: "„Éí„É£", r: "hya" }, { h: "„Å≤„ÇÖ", k: "„Éí„É•", r: "hyu" }, { h: "„Å≤„Çá", k: "„Éí„Éß", r: "hyo" },
          { h: "„Åø„ÇÉ", k: "„Éü„É£", r: "mya" }, { h: "„Åø„ÇÖ", k: "„Éü„É•", r: "myu" }, { h: "„Åø„Çá", k: "„Éü„Éß", r: "myo" },
          { h: "„Çä„ÇÉ", k: "„É™„É£", r: "rya" }, { h: "„Çä„ÇÖ", k: "„É™„É•", r: "ryu" }, { h: "„Çä„Çá", k: "„É™„Éß", r: "ryo" }
        ]
      },
      {
        name: "Contracted Voiced", nameKey: "grp_con3", entries: [
          { h: "„Åé„ÇÉ", k: "„ÇÆ„É£", r: "gya" }, { h: "„Åé„ÇÖ", k: "„ÇÆ„É•", r: "gyu" }, { h: "„Åé„Çá", k: "„ÇÆ„Éß", r: "gyo" },
          { h: "„Åò„ÇÉ", k: "„Ç∏„É£", r: "ja", alt: ["jya", "zya"] }, { h: "„Åò„ÇÖ", k: "„Ç∏„É•", r: "ju", alt: ["jyu", "zyu"] }, { h: "„Åò„Çá", k: "„Ç∏„Éß", r: "jo", alt: ["jyo", "zyo"] },
          { h: "„Å≥„ÇÉ", k: "„Éì„É£", r: "bya" }, { h: "„Å≥„ÇÖ", k: "„Éì„É•", r: "byu" }, { h: "„Å≥„Çá", k: "„Éì„Éß", r: "byo" },
          { h: "„Å¥„ÇÉ", k: "„Éî„É£", r: "pya" }, { h: "„Å¥„ÇÖ", k: "„Éî„É•", r: "pyu" }, { h: "„Å¥„Çá", k: "„Éî„Éß", r: "pyo" }
        ]
      }
    ];

    // JAPANESE_WORDS is now loaded from dictionary.js
    const MEMORIZE_THRESHOLD = 3;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let currentMode = 'normal'; // 'normal', 'easy', 'simple', 'draw', 'easy-kk', 'draw-kk', 'audio-select', 'audio-draw', 'read-word'
    let feedbackActive = false; // guard against stacking feedback/nextQuestion calls
    let sessionActive = false;  // guard against sprint timer race condition
    let selectedEntries = [];   // entries chosen on selection screen
    let stats = {};             // romaji -> { h: {shown,correct}, k: {shown,correct} }
    let sessionTotal = 0;
    let sessionCorrect = 0;
    let seenChars = new Set();
    let mistakes = {};    // key -> { entry, script, count }
    let startTime = null;
    let currentEntry = null;
    let currentScript = null;  // 'h' or 'k'
    let sprintTimer = null;
    let sprintTimeLeft = 0;
    let isPracticeMode = false;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  DRAWING LOGIC
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const canvas = document.getElementById('draw-canvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    function clearCanvas() {
      ctx.fillStyle = '#1e2330';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    clearCanvas();

    function startDraw(e) {
      isDrawing = true;
      const pos = getMousePos(e);
      lastX = pos.x;
      lastY = pos.y;
    }

    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      const pos = getMousePos(e);

      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.strokeStyle = '#e8eaf0';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();

      lastX = pos.x;
      lastY = pos.y;
    }

    function stopDraw() {
      isDrawing = false;
      ctx.beginPath();
    }

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      if (evt.touches && evt.touches.length > 0) {
        return {
          x: (evt.touches[0].clientX - rect.left) * scaleX,
          y: (evt.touches[0].clientY - rect.top) * scaleY
        };
      }
      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY
      };
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDraw);
    canvas.addEventListener('mouseout', stopDraw);

    canvas.addEventListener('touchstart', startDraw, { passive: false });
    canvas.addEventListener('touchmove', draw, { passive: false });
    canvas.addEventListener('touchend', stopDraw, { passive: false });
    canvas.addEventListener('touchcancel', stopDraw, { passive: false });

    document.getElementById('btn-draw-clear').addEventListener('click', clearCanvas);
    document.getElementById('btn-draw-show').addEventListener('click', () => {
      // Reveal answer in kana-char
      const charEl = document.getElementById('kana-char');

      let ans = '';
      if (currentMode === 'draw-kk') {
        ans = currentScript === 'h' ? currentEntry.k : currentEntry.h;
      } else if (currentMode === 'audio-draw') {
        // Audio-draw: user heard the kana and must draw it
        ans = currentScript === 'h' ? currentEntry.h : currentEntry.k;
      } else {
        ans = currentScript === 'h' ? currentEntry.h : currentEntry.k;
      }

      document.getElementById('draw-submit-area').style.display = 'none';
      document.getElementById('self-grade').style.display = 'flex';

      const unicodeHex = ans.charCodeAt(0).toString(16).padStart(5, '0');
      const svgUrl = `https://raw.githubusercontent.com/KanjiVG/kanjivg/master/kanji/${unicodeHex}.svg`;

      // Temporary loading state
      charEl.style.fontFamily = "'Inter', sans-serif";
      charEl.style.color = "var(--muted)";
      charEl.innerHTML = `<span style="font-size: 0.25em;">Loading stroke order...</span>`;

      fetch(svgUrl)
        .then(res => {
          if (!res.ok) throw new Error("SVG missing");
          return res.text();
        })
        .then(svgText => {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, "image/svg+xml");
          const paths = Array.from(doc.querySelectorAll('path'));

          let svgContent = `<svg viewBox="0 0 109 109" style="width: 140px; height: 140px; display: inline-block;">`;
          paths.forEach((p, index) => {
            const d = p.getAttribute('d');
            const delay = index * 1.0;
            // Provide stroke order animation with delays
            svgContent += `<path d="${d}" fill="none" class="stroke-anim" stroke="var(--text)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" style="animation-delay: ${delay}s;" />`;
          });
          svgContent += `</svg>`;
          charEl.innerHTML = svgContent;
        })
        .catch(err => {
          // Fallback to text string
          charEl.style.fontFamily = "'Noto Sans JP', sans-serif";
          charEl.style.color = "";
          charEl.innerHTML = `<span>${ans}</span>`;
        });
    });

    document.getElementById('btn-self-correct').addEventListener('click', () => submitAnswer(null, null, true));
    document.getElementById('btn-self-wrong').addEventListener('click', () => submitAnswer(null, null, false));

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  AUDIO LOGIC
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let jpVoice = null;
    let audioPlaying = false;
    let currentAudio = null;

    function initSpeechSynthesis() {
      const loadVoices = () => {
        const voices = speechSynthesis.getVoices();
        const jaVoices = voices.filter(v => v.lang === 'ja-JP' || v.lang.startsWith('ja'));

        if (jaVoices.length > 0) {
          // Prefer high-quality voices: Google > Kyoko > O-Ren > any non-compact
          const preferred = ['google', 'kyoko', 'o-ren', 'haruka', 'sayaka', 'enhanced', 'premium'];
          const avoid = ['compact', 'espeak'];

          jpVoice = jaVoices.find(v => {
            const name = v.name.toLowerCase();
            return preferred.some(p => name.includes(p)) && !avoid.some(a => name.includes(a));
          });

          if (!jpVoice) {
            // Pick any non-compact Japanese voice
            jpVoice = jaVoices.find(v => !avoid.some(a => v.name.toLowerCase().includes(a)));
          }

          if (!jpVoice) jpVoice = jaVoices[0];
        }
      };

      speechSynthesis.onvoiceschanged = loadVoices;
      loadVoices();
    }
    initSpeechSynthesis();

    function playAudioChar(char) {
      if (audioPlaying) return;
      audioPlaying = true;

      // Stop any currently playing audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }
      speechSynthesis.cancel();

      // Primary: Google Translate TTS (much higher quality Japanese pronunciation)
      const encoded = encodeURIComponent(char);
      const ttsUrl = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=ja&q=${encoded}`;

      const audio = new Audio(ttsUrl);
      currentAudio = audio;
      audio.playbackRate = 0.9;

      const unlock = () => { audioPlaying = false; };

      audio.onended = unlock;
      audio.onerror = () => {
        // Fallback: SpeechSynthesis
        unlock();
        playAudioFallback(char);
      };

      audio.play().catch(() => {
        unlock();
        playAudioFallback(char);
      });
    }

    function playAudioFallback(char) {
      if (!('speechSynthesis' in window)) return;
      const utterance = new SpeechSynthesisUtterance(char);
      utterance.lang = 'ja-JP';
      if (jpVoice) utterance.voice = jpVoice;
      utterance.rate = 0.8;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      speechSynthesis.speak(utterance);
    }

    document.getElementById('btn-replay-audio').addEventListener('click', () => {
      const scriptChar = currentScript === 'h' ? currentEntry.h : currentEntry.k;
      playAudioChar(scriptChar);
    });

    document.getElementById('kana-char').addEventListener('click', () => {
      if (currentMode === 'read-word') {
        playAudioChar(currentEntry.h); // speak hiragana, not romaji
      } else {
        const isAudioLike = currentMode === 'audio-select' || currentMode === 'audio-draw';
        if (!isAudioLike) {
          const scriptChar = currentScript === 'h' ? currentEntry.h : currentEntry.k;
          playAudioChar(scriptChar);
        }
      }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  SELECTION SCREEN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function buildSelectionScreen() {
      const list = document.getElementById('group-list');
      list.innerHTML = '';

      KANA_GROUPS.forEach((group, gi) => {
        const block = document.createElement('div');
        block.className = 'group-block';

        // group header with master checkbox
        const hdr = document.createElement('div');
        hdr.className = 'group-header';

        const masterCb = document.createElement('input');
        masterCb.type = 'checkbox';
        masterCb.id = `grp-cb-${gi}`;
        masterCb.checked = true;

        const lbl = document.createElement('label');
        lbl.htmlFor = masterCb.id;
        lbl.textContent = t(group.nameKey);
        lbl.dataset.i18n = group.nameKey;

        const cnt = document.createElement('span');
        cnt.id = `grp-cnt-${gi}`;

        hdr.appendChild(masterCb);
        hdr.appendChild(lbl);
        hdr.appendChild(cnt);
        block.appendChild(hdr);

        // entries grid
        const grid = document.createElement('div');
        grid.className = 'group-entries';

        group.entries.forEach((entry, ei) => {
          const row = document.createElement('label');
          row.className = 'kana-entry';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.dataset.gi = gi;
          cb.dataset.ei = ei;
          cb.checked = true;
          cb.addEventListener('change', () => updateGroupState(gi));

          const chars = document.createElement('div');
          chars.className = 'kana-chars';
          chars.innerHTML = `<span class="hira">${entry.h}</span><span class="kata">${entry.k}</span>`;

          const roma = document.createElement('span');
          roma.className = 'kana-roma';
          roma.textContent = entry.r;

          row.appendChild(cb);
          row.appendChild(chars);
          row.appendChild(roma);
          grid.appendChild(row);
        });

        block.appendChild(grid);
        list.appendChild(block);

        // master checkbox toggles all in group
        masterCb.addEventListener('change', () => {
          getGroupCheckboxes(gi).forEach(cb => cb.checked = masterCb.checked);
          updateGroupState(gi);
        });

        updateGroupState(gi);
      });

      updateSelCount();
    }

    function getGroupCheckboxes(gi) {
      return Array.from(document.querySelectorAll(`input[data-gi="${gi}"]`));
    }

    function updateGroupState(gi) {
      const cbs = getGroupCheckboxes(gi);
      const total = cbs.length;
      const checked = cbs.filter(c => c.checked).length;
      const masterCb = document.getElementById(`grp-cb-${gi}`);
      const cnt = document.getElementById(`grp-cnt-${gi}`);

      masterCb.checked = checked === total;
      masterCb.indeterminate = checked > 0 && checked < total;
      cnt.textContent = `${checked}/${total}`;
      updateSelCount();
    }

    function getAllEntryCheckboxes() {
      return Array.from(document.querySelectorAll('.kana-entry input[type=checkbox]'));
    }

    function updateSelCount() {
      const checked = getAllEntryCheckboxes().filter(c => c.checked).length;
      document.getElementById('sel-count').innerHTML =
        `<strong>${checked}</strong> ${t('sel_count_label')}`;
      document.getElementById('btn-start').disabled = checked === 0;
    }

    document.getElementById('btn-all').addEventListener('click', () => {
      getAllEntryCheckboxes().forEach(cb => cb.checked = true);
      KANA_GROUPS.forEach((_, gi) => updateGroupState(gi));
    });

    document.getElementById('btn-none').addEventListener('click', () => {
      getAllEntryCheckboxes().forEach(cb => cb.checked = false);
      KANA_GROUPS.forEach((_, gi) => updateGroupState(gi));
    });

    document.getElementById('btn-reset-stats').addEventListener('click', () => {
      if (confirm(t('alert_reset_confirm'))) {
        localStorage.removeItem('kanaQuizStats');
        localStorage.removeItem('kanaQuizMistakes');
        alert(t('alert_reset_done'));
      }
    });

    document.getElementById('cb-practice').addEventListener('change', (e) => {
      const charModeSelect = document.getElementById('sel-char-mode');
      if (e.target.checked) {
        charModeSelect.disabled = false;
      } else {
        charModeSelect.disabled = true;
        charModeSelect.value = 'all';
      }
    });

    [
      { id: 'mode-normal', val: 'normal' },
      { id: 'mode-easy', val: 'easy' },
      { id: 'mode-easy-kk', val: 'easy-kk' },
      { id: 'mode-audio-select', val: 'audio-select' },
      { id: 'mode-simple', val: 'simple' },
      { id: 'mode-draw', val: 'draw' },
      { id: 'mode-read-word', val: 'read-word' },
      { id: 'mode-draw-kk', val: 'draw-kk' },
      { id: 'mode-audio-draw', val: 'audio-draw' }
    ].forEach(m => {
      document.getElementById(m.id).addEventListener('click', (e) => {
        currentMode = m.val;
        document.querySelectorAll('.mode-toggle button').forEach(b => b.classList.remove('active'));
        e.currentTarget.classList.add('active');
      });
    });

    document.getElementById('btn-start').addEventListener('click', startQuiz);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  QUIZ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function startQuiz() {
      // collect selected entries
      selectedEntries = [];
      let allowedRomaji = new Set();
      getAllEntryCheckboxes().forEach(cb => {
        if (cb.checked) {
          const g = KANA_GROUPS[cb.dataset.gi];
          const entry = g.entries[cb.dataset.ei];
          if (currentMode !== 'read-word') {
            selectedEntries.push(entry);
          } else {
            allowedRomaji.add(entry.r);
            if (entry.alt) entry.alt.forEach(a => allowedRomaji.add(a));
          }
        }
      });

      if (currentMode === 'read-word') {
        // Filter JAPANESE_WORDS to only those that can be formed by allowedRomaji
        // Note: we check if the word's romaji can be broken down into allowed syllables.
        // A simple check is to require the exact romaji to only contain allowed chunks.
        // For a basic implementation, we just check if every character in the word's kana
        // exists in the checked entries. But wait, JAPANESE_WORDS doesn't map kana to entries.
        // Let's just collect all allowed Hiragana and Katakana characters into a Set.
        let allowedChars = new Set();
        getAllEntryCheckboxes().forEach(cb => {
          if (cb.checked) {
            const g = KANA_GROUPS[cb.dataset.gi];
            const e = g.entries[cb.dataset.ei];
            [...e.h].forEach(c => allowedChars.add(c));
            [...e.k].forEach(c => allowedChars.add(c));
          }
        });

        JAPANESE_WORDS.forEach(word => {
          let canFormH = [...word.h].every(c => allowedChars.has(c));
          let canFormK = [...word.k].every(c => allowedChars.has(c));
          if (canFormH || canFormK) {
            selectedEntries.push(word);
          }
        });

        if (selectedEntries.length === 0) {
          alert(t('alert_no_words') || "Not enough Kana selected to form any practice words. Please select more groups.");
          showScreen('select');
          return;
        }
      }

      // init stats
      stats = {};
      try {
        const savedStats = JSON.parse(localStorage.getItem('kanaQuizStats'));
        if (savedStats) stats = savedStats;
      } catch (e) { }

      if (currentMode !== 'read-word') {
        selectedEntries.forEach(e => {
          if (!stats[e.r]) {
            stats[e.r] = { h: { shown: 0, correct: 0 }, k: { shown: 0, correct: 0 } };
          }
        });
      }

      sessionTotal = 0;
      sessionCorrect = 0;
      seenChars = new Set();

      mistakes = {};
      try {
        const savedMistakes = JSON.parse(localStorage.getItem('kanaQuizMistakes'));
        if (savedMistakes) mistakes = savedMistakes;
      } catch (e) { }

      startTime = Date.now();
      isPracticeMode = document.getElementById('cb-practice').checked;

      if (document.getElementById('cb-sprint').checked) {
        sprintTimeLeft = 60;
        const timerEl = document.getElementById('q-timer');
        timerEl.style.display = 'inline-block';
        timerEl.textContent = `‚è±Ô∏è ${sprintTimeLeft}s`;
        sprintTimer = setInterval(() => {
          sprintTimeLeft--;
          if (sprintTimeLeft <= 0) {
            clearInterval(sprintTimer);
            sprintTimer = null;
            timerEl.textContent = `‚è±Ô∏è 0s`;
            endSession();
          } else {
            timerEl.textContent = `‚è±Ô∏è ${sprintTimeLeft}s`;
          }
        }, 1000);
      } else {
        document.getElementById('q-timer').style.display = 'none';
      }

      sessionActive = true;
      showScreen('quiz');
      nextQuestion();
      document.getElementById('romaji-input').focus();
    }

    function nextQuestion() {
      currentEntry = selectedEntries[Math.floor(Math.random() * selectedEntries.length)];

      let charMode = document.getElementById('sel-char-mode').value;
      if (!isPracticeMode) charMode = 'all';

      if (charMode === 'h') {
        currentScript = 'h';
      } else if (charMode === 'k') {
        currentScript = 'k';
      } else {
        currentScript = Math.random() < 0.5 ? 'h' : 'k';
      }

      const isSimpleLike = currentMode === 'simple' || currentMode === 'draw';
      const isKKLike = currentMode === 'easy-kk' || currentMode === 'draw-kk';
      const isAudioLike = currentMode === 'audio-select' || currentMode === 'audio-draw';
      const isReadWord = currentMode === 'read-word';

      const char = isSimpleLike ? currentEntry.r : (currentScript === 'h' ? currentEntry.h : currentEntry.k);

      const scriptChar = currentScript === 'h' ? currentEntry.h : currentEntry.k;

      // Still consider the target script as seen for stats, even if showing romaji/playing audio
      if (!isReadWord) {
        seenChars.add(scriptChar);
      }

      let headerLabel = currentScript === 'h' ? t('lbl_hiragana') : t('lbl_katakana');
      if (currentMode === 'simple' || currentMode === 'draw') {
        headerLabel = t('lbl_romaji') + ' ‚Üí ' + (currentScript === 'h' ? t('lbl_hiragana') : t('lbl_katakana'));
      } else if (currentMode === 'easy-kk' || currentMode === 'draw-kk') {
        headerLabel = (currentScript === 'h' ? t('lbl_hiragana') : t('lbl_katakana')) + ' ‚Üí ' + (currentScript === 'h' ? t('lbl_katakana') : t('lbl_hiragana'));
      } else if (currentMode === 'audio-select' || currentMode === 'audio-draw') {
        headerLabel = t('lbl_audio') + ' ‚Üí ' + (currentScript === 'h' ? t('lbl_hiragana') : t('lbl_katakana'));
      } else if (currentMode === 'read-word') {
        headerLabel = t('mode_read_word').replace('<br>', ' ');
      }
      document.getElementById('script-label').innerHTML = headerLabel;

      // Update font styling for the display character
      const charEl = document.getElementById('kana-char');
      const audioBtnDiv = document.getElementById('audio-btn-container');

      charEl.style.fontFamily = isSimpleLike ? "'Inter', sans-serif" : "'Noto Sans JP', sans-serif";
      charEl.style.color = isSimpleLike ? "var(--accent2)" : "";

      audioBtnDiv.style.display = 'none';

      if (isAudioLike) {
        charEl.innerHTML = `<div style="font-size: 0.3em; color: var(--muted); margin-top: 10px;">${t('listen_label')}</div>`;
        audioBtnDiv.style.display = 'flex';
        playAudioChar(scriptChar);
      } else if (currentMode === 'draw' || currentMode === 'draw-kk') {
        charEl.innerHTML = `<span>${char}</span><div style="font-size: 0.2em; color: var(--muted); margin-top: 10px;">Draw above</div>`;
      } else {
        charEl.textContent = char;
      }

      document.getElementById('q-progress').textContent = `Q ${sessionTotal + 1}`;

      const inpRow = document.getElementById('input-row');
      const grid = document.getElementById('easy-grid');
      const drawArea = document.getElementById('draw-area');

      // Reset draw block elements
      drawArea.style.display = 'none';
      grid.style.display = 'none';
      inpRow.style.display = 'none';

      if (currentMode === 'easy' || currentMode === 'simple' || currentMode === 'easy-kk' || currentMode === 'audio-select') {
        inpRow.style.display = 'none';
        grid.style.display = 'grid';
        grid.innerHTML = '';

        // determine options pool precisely from user selection
        let poolItems = [];
        let targetAns = '';

        if (currentMode === 'simple' || currentMode === 'audio-select') {
          poolItems = selectedEntries.map(e => currentScript === 'h' ? e.h : e.k);
          targetAns = currentScript === 'h' ? currentEntry.h : currentEntry.k;
        } else if (currentMode === 'easy-kk') {
          poolItems = selectedEntries.map(e => currentScript === 'h' ? e.k : e.h);
          targetAns = currentScript === 'h' ? currentEntry.k : currentEntry.h;
        } else {
          // 'easy' mode
          poolItems = selectedEntries.map(e => e.r);
          targetAns = currentEntry.r;
        }

        let pool = [...new Set(poolItems)];
        let optionsCount = Math.min(10, pool.length);

        let options = [targetAns];

        while (options.length < optionsCount) {
          let cand = pool[Math.floor(Math.random() * pool.length)];
          if (!options.includes(cand)) options.push(cand);
        }
        options.sort(() => Math.random() - 0.5); // shuffle

        options.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = (currentMode === 'simple' || currentMode === 'easy-kk' || currentMode === 'audio-select') ? 'easy-btn simple-btn' : 'easy-btn';
          btn.textContent = opt;
          btn.onclick = () => submitAnswer(opt, btn);
          grid.appendChild(btn);
        });
      } else if (currentMode === 'draw' || currentMode === 'draw-kk' || currentMode === 'audio-draw') {
        drawArea.style.display = 'flex';
        document.getElementById('draw-submit-area').style.display = 'flex';
        document.getElementById('self-grade').style.display = 'none';
        clearCanvas();
      } else {
        inpRow.style.display = 'flex';
        grid.style.display = 'none';
        const inp = document.getElementById('romaji-input');
        inp.value = '';
        inp.className = '';
        inp.focus();
      }
    }

    function submitAnswer(optAnswer = null, btnEl = null, selfGradedCorrect = null) {
      const inp = document.getElementById('romaji-input');
      const answer = (optAnswer || inp.value).trim().toLowerCase();
      // Only block empty answers for normal text mode
      if (!answer && (currentMode === 'normal' || currentMode === 'read-word')) return;
      if (feedbackActive) return; // prevent double-submit during feedback animation

      const isSimpleLike = currentMode === 'simple' || currentMode === 'draw';
      const isKKLike = currentMode === 'easy-kk' || currentMode === 'draw-kk';
      const isAudioLike = currentMode === 'audio-select' || currentMode === 'audio-draw';

      let expected = currentEntry.r;
      if (isSimpleLike || isAudioLike) {
        expected = currentScript === 'h' ? currentEntry.h : currentEntry.k;
      } else if (isKKLike) {
        expected = currentScript === 'h' ? currentEntry.k : currentEntry.h;
      }

      // Normalize macrons for typed romaji comparison (read-word / normal modes)
      const normalizeMacrons = s => s.replace(/≈ç/g, 'ou').replace(/≈´/g, 'uu').replace(/ƒì/g, 'ei').replace(/ƒÅ/g, 'aa').replace(/ƒ´/g, 'ii');
      const key = currentScript === 'h' ? 'h' : 'k';

      const isReadWord = currentMode === 'read-word';

      // Record stats only for normal kana modes, avoid cluttering stats with full words for now
      if (!isReadWord) {
        const formStat = stats[currentEntry.r][key];
        formStat.shown++;
      }
      sessionTotal++;

      let correct = false;
      if (currentMode === 'draw' || currentMode === 'draw-kk' || currentMode === 'audio-draw') {
        correct = selfGradedCorrect;
      } else {
        correct = answer === expected || normalizeMacrons(answer) === normalizeMacrons(expected);
        // Check alt spelling
        if (!correct && currentMode === 'normal' && currentEntry.alt && currentEntry.alt.includes(answer)) {
          correct = true;
        }
      }

      if (currentMode === 'easy' || currentMode === 'simple' || currentMode === 'easy-kk' || currentMode === 'audio-select') {
        document.querySelectorAll('.easy-btn').forEach(b => b.disabled = true);
        if (correct) {
          btnEl.classList.add('correct');
        } else {
          btnEl.classList.add('wrong');
          document.querySelectorAll('.easy-btn').forEach(b => {
            if (b.textContent === expected) b.classList.add('correct');
          });
        }
      } else if (currentMode === 'normal' || currentMode === 'read-word') {
        if (correct) inp.classList.add('correct');
        else inp.classList.add('wrong');
      }

      if (correct) {
        sessionCorrect++;
        if (!isReadWord) stats[currentEntry.r][key].correct++;

        if (currentMode === 'draw' || currentMode === 'draw-kk' || currentMode === 'audio-draw') setTimeout(() => nextQuestion(), 100);
        else {
          let extraTxt = isReadWord ? `${currentLang === 'zh' ? currentEntry.z : currentEntry.e}` : null;
          showFeedback(true, expected, extraTxt);
        }
      } else {
        if (currentMode === 'draw' || currentMode === 'draw-kk' || currentMode === 'audio-draw') setTimeout(() => nextQuestion(), 100);
        else {
          let extraTxt = isReadWord ? `${currentLang === 'zh' ? currentEntry.z : currentEntry.e}` : null;
          showFeedback(false, expected, extraTxt);
        }

        if (!isReadWord) {
          const mk = `${currentEntry.h}|${expected}`;
          if (!mistakes[mk]) {
            mistakes[mk] = { entry: currentEntry, script: currentScript === 'h' ? 'h' : 'k', count: 0 };
          }
          mistakes[mk].count++;
        }
      }

      updateQuizMeta();
    }

    function updateQuizMeta() {
      const wrong = sessionTotal - sessionCorrect;
      document.getElementById('q-score').innerHTML =
        `‚úì ${sessionCorrect} &nbsp; ‚úó ${wrong}`;

      // Save stats
      if (!isPracticeMode) {
        try {
          localStorage.setItem('kanaQuizStats', JSON.stringify(stats));
          localStorage.setItem('kanaQuizMistakes', JSON.stringify(mistakes));
        } catch (e) {
          console.error('Failed to save to localStorage', e);
        }
      }
    }

    function showFeedback(ok, expected, extraText = null) {
      if (feedbackActive) return;
      feedbackActive = true;

      const overlay = document.getElementById('feedback');
      const bubble = document.getElementById('feedback-bubble');

      let baseTxt = ok ? '‚úì Correct!' : `‚úó  ${expected}`;
      if (extraText) baseTxt += `<br><small style="font-weight:normal; font-size:0.7em;">${extraText}</small>`;

      bubble.innerHTML = baseTxt;
      bubble.className = `feedback-bubble ${ok ? 'ok' : 'bad'}`;

      const duration = ok ? 800 : (extraText ? 3500 : 2500); // Longer for errors or words

      overlay.classList.add('active');
      requestAnimationFrame(() => {
        bubble.classList.add('show');
        setTimeout(() => {
          bubble.classList.remove('show');
          overlay.classList.remove('active');
          setTimeout(() => {
            feedbackActive = false;
            if (sessionActive) nextQuestion();
          }, 180);
        }, duration);
      });
    }

    document.getElementById('submit-btn').addEventListener('click', () => submitAnswer());
    document.getElementById('romaji-input').addEventListener('keydown', e => {
      if (e.key === 'Enter') submitAnswer();
    });
    const romajiInput = document.getElementById('romaji-input');
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    if (isIOS) {
      romajiInput.addEventListener('focus', () => {
        setTimeout(() => window.scrollTo(0, 0), 50);
        setTimeout(() => window.scrollTo(0, 0), 300);
      });
      window.addEventListener('scroll', () => {
        if (document.activeElement === romajiInput) {
          window.scrollTo(0, 0);
          document.body.scrollTop = 0;
        }
      });
    } else {
      romajiInput.addEventListener('focus', () => {
        setTimeout(() => window.scrollTo(0, 0), 100);
      });
    }
    document.getElementById('btn-end').addEventListener('click', endSession);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  SUMMARY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function isFormMemorized(f) {
      return f.shown >= MEMORIZE_THRESHOLD && f.correct === f.shown;
    }
    function isEntryMemorized(e) {
      const s = stats[e.r];
      return s && isFormMemorized(s.h) && isFormMemorized(s.k);
    }

    function endSession() {
      sessionActive = false;

      if (sprintTimer) {
        clearInterval(sprintTimer);
        sprintTimer = null;
      }

      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      const wrong = sessionTotal - sessionCorrect;
      const score = sessionTotal ? (sessionCorrect / sessionTotal * 100).toFixed(1) : '‚Äî';
      const now = new Date();

      // stats grid
      const grid = document.getElementById('stats-grid');
      const statsData = [
        { val: sessionTotal, lbl: t('stat_questions') },
        { val: sessionCorrect, lbl: t('stat_correct') },
        { val: wrong, lbl: t('stat_incorrect') },
        { val: seenChars.size, lbl: t('stat_distinct') },
        { val: `${mins}m ${String(secs).padStart(2, '0')}s`, lbl: t('stat_duration'), full: false },
        { val: `${score}%`, lbl: t('stat_score'), full: false },
      ];
      grid.innerHTML = statsData.map(s =>
        `<div class="stat-box${s.full ? ' full' : ''}">
       <div class="val">${s.val}</div>
       <div class="lbl">${s.lbl}</div>
     </div>`
      ).join('');

      // memorization bar
      const memoCard = document.getElementById('memo-card');
      if (isPracticeMode) {
        memoCard.style.display = 'none';
      } else {
        memoCard.style.display = 'block';
        const newlyMemorized = selectedEntries.filter(isEntryMemorized);
        const memorizedCount = newlyMemorized.length;
        const pct = selectedEntries.length ? (memorizedCount / selectedEntries.length * 100) : 0;
        document.getElementById('memo-fill').style.width = pct + '%';
        document.getElementById('memo-label').textContent =
          `Memorized ${memorizedCount} / ${selectedEntries.length} entries`;

        const memoResults = document.getElementById('memo-results');
        const memoList = document.getElementById('memo-list');
        if (newlyMemorized.length > 0) {
          memoResults.style.display = 'block';
          memoList.innerHTML = newlyMemorized.map(e =>
            `<div class="memo-tag">${e.h} / ${e.k} (${e.r})</div>`
          ).join('');
        } else {
          memoResults.style.display = 'none';
        }
      }

      // mistakes table
      const mkList = Object.values(mistakes).sort((a, b) => b.count - a.count);
      if (mkList.length) {
        document.getElementById('mistakes-section').style.display = 'block';
        document.getElementById('mistakes-tbody').innerHTML = mkList.map(mistake =>
          `<tr>
        <td>${mistake.entry.h}</td>
            <td>${mistake.entry.k}</td>
            <td class="roma">${mistake.entry.r}</td>
            <td class="roma">${mistake.script === 'h' ? t('lbl_hiragana') : t('lbl_katakana')}</td>
            <td class="errs">${mistake.count}</td>
       </tr>`
        ).join('');
      } else {
        document.getElementById('mistakes-section').style.display = 'none';
      }

      document.getElementById('sum-date').textContent =
        now.toLocaleString();

      showScreen('summary');
    }



    document.getElementById('btn-retry').addEventListener('click', () => {
      startQuiz();
    });
    document.getElementById('btn-reselect').addEventListener('click', () => {
      showScreen('select');
    });

    // Review Weaknesses: auto-select Kana with past mistakes
    document.getElementById('btn-review-weak').addEventListener('click', () => {
      let savedMistakes = {};
      try { savedMistakes = JSON.parse(localStorage.getItem('kanaQuizMistakes')) || {}; } catch (e) { }
      const weakRomaji = new Set(Object.values(savedMistakes).map(m => m.entry.r));
      if (weakRomaji.size === 0) {
        alert(t('alert_no_weak'));
        return;
      }
      getAllEntryCheckboxes().forEach(cb => {
        const gi = parseInt(cb.dataset.gi);
        const ei = parseInt(cb.dataset.ei);
        const entry = KANA_GROUPS[gi].entries[ei];
        cb.checked = weakRomaji.has(entry.r);
      });
      KANA_GROUPS.forEach((_, gi) => updateGroupState(gi));
    });

    // Progress Dashboard: render mastery grid from localStorage
    document.getElementById('btn-progress').addEventListener('click', () => {
      let savedStats = {};
      try { savedStats = JSON.parse(localStorage.getItem('kanaQuizStats')) || {}; } catch (e) { }

      const container = document.getElementById('progress-content');
      container.innerHTML = '';

      KANA_GROUPS.forEach(group => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'kana-mastery-group';
        groupDiv.innerHTML = `<h3>${t(group.nameKey)}</h3>`;

        const grid = document.createElement('div');
        grid.className = 'kana-mastery-grid';

        group.entries.forEach(entry => {
          const s = savedStats[entry.r];
          const cell = document.createElement('div');
          cell.className = 'kana-mastery-cell';

          // Compute overall mastery level (0=unseen, 1=struggling, 2=in progress, 3=memorized)
          let level = 0;
          if (s) {
            const hMem = s.h && s.h.shown >= 3 && s.h.correct === s.h.shown;
            const kMem = s.k && s.k.shown >= 3 && s.k.correct === s.k.shown;
            const hSeen = s.h && s.h.shown > 0;
            const kSeen = s.k && s.k.shown > 0;
            if (hMem && kMem) level = 3;
            else if (hSeen || kSeen) {
              const totalShown = (s.h ? s.h.shown : 0) + (s.k ? s.k.shown : 0);
              const totalCorrect = (s.h ? s.h.correct : 0) + (s.k ? s.k.correct : 0);
              const accuracy = totalShown > 0 ? totalCorrect / totalShown : 0;
              level = accuracy >= 0.7 ? 2 : 1;
            }
          }
          cell.classList.add(`mastery-${level}`);
          cell.innerHTML = `${entry.h}<sub>${entry.r}</sub>`;
          cell.title = `${entry.h} / ${entry.k} (${entry.r})`;
          grid.appendChild(cell);
        });

        groupDiv.appendChild(grid);
        container.appendChild(groupDiv);
      });

      showScreen('progress');
    });

    document.getElementById('btn-progress-back').addEventListener('click', () => showScreen('select'));

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  SCREEN ROUTER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function showScreen(name) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      const activeScreen = document.getElementById(`screen-${name}`);
      activeScreen.classList.add('active');

      const app = document.getElementById('app');

      window.scrollTo(0, 0);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  I18N
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const TRANSLATIONS = {
      en: {
        sel_subtitle: 'Select the kana you want to practice',
        sel_all: 'Select All',
        sel_none: 'Deselect All',
        sel_review: 'Review Weaknesses',
        sel_progress: 'Progress',
        sel_reset: 'Reset Stats',
        sel_sprint: 'Timed Sprint (60s)',
        sel_practice: 'Practice',
        sel_char_mode: 'Character:',
        opt_all: 'All',
        opt_hiragana_only: 'Hiragana',
        opt_katakana_only: 'Katakana',
        sel_start: 'Start Quiz',
        quiz_end: 'End',
        draw_clear: 'Clear',
        draw_show: 'Show Answer',
        draw_wrong: 'Incorrect',
        draw_correct: 'Correct',
        sum_title: 'Session Summary',
        sum_memo_rule: 'Rule: ‚â• 3 shown & all correct for both hiragana and katakana',
        sum_newly_mem: 'Newly Memorized Characters',
        sum_got_wrong: 'Characters you got wrong',
        th_romaji: 'Romaji',
        th_script: 'Script',
        th_errors: 'Errors',
        sum_retry: 'Practice Again',
        sum_reselect: 'Change Selection',
        prog_title: 'Progress',
        prog_back: '‚Üê Back',
        prog_struggling: 'Struggling',
        prog_inprogress: 'In Progress',
        prog_memorized: 'Memorized',
        prog_unseen: 'Unseen',
        alert_no_weak: 'No weakness data found yet. Complete a quiz session first!',
        alert_reset_confirm: 'Are you sure you want to reset all your memorized stats and mistakes?',
        alert_reset_done: 'Stats have been reset.',
        listen_label: 'Listen carefully!',
        grp_vowels: 'Vowels',
        grp_k: 'K row',
        grp_s: 'S row',
        grp_t: 'T row',
        grp_n: 'N row',
        grp_h: 'H row',
        grp_m: 'M row',
        grp_y: 'Y row',
        grp_r: 'R row',
        grp_w: 'W row / N',
        grp_g: 'G row (voiced)',
        grp_z: 'Z row (voiced)',
        grp_d: 'D row (voiced)',
        grp_b: 'B row (voiced)',
        grp_p: 'P row (semi-voiced)',
        grp_con1: 'Contracted (K, S, T, N)',
        grp_con2: 'Contracted (H, M, R)',
        grp_con3: 'Contracted Voiced',
        mode_type_kr: 'Type<br>(Kana‚ÜíR)',
        mode_sel_kr: 'Select<br>(Kana‚ÜíR)',
        mode_sel_hk: 'Select<br>(H‚ÜîK)',
        mode_sel_ak: 'Select<br>(üîä‚ÜíKana)',
        mode_sel_rk: 'Select<br>(R‚ÜíKana)',
        mode_read_word: 'Read Word<br>(Type Romaji)',
        mode_draw_rk: 'Draw<br>(R‚ÜíKana)',
        mode_draw_hk: 'Draw<br>(H‚ÜîK)',
        mode_draw_ak: 'Draw<br>(üîä‚ÜíKana)',
        lbl_hiragana: 'Hiragana',
        lbl_katakana: 'Katakana',
        lbl_romaji: 'Romaji',
        lbl_audio: 'Audio',
        alert_no_words: 'Not enough Kana selected to form any practice words. Please select more groups.',
        sel_count_label: 'entries selected',
        stat_questions: 'Questions',
        stat_correct: 'Correct',
        stat_incorrect: 'Incorrect',
        stat_distinct: 'Distinct Chars',
        stat_duration: 'Duration',
        stat_score: 'Score',
      },
      zh: {
        sel_subtitle: 'ÈÄâÊã©ÊÉ≥Ë¶ÅÁªÉ‰π†ÁöÑÂÅáÂêç',
        sel_all: 'ÂÖ®ÈÄâ',
        sel_none: 'ÂèñÊ∂àÂÖ®ÈÄâ',
        sel_review: 'Â§ç‰π†Âº±È°π',
        sel_progress: 'Â≠¶‰π†ËøõÂ∫¶',
        sel_reset: 'ÈáçÁΩÆÊï∞ÊçÆ',
        sel_sprint: 'ËÆ°Êó∂ÂÜ≤Âà∫Ôºà60ÁßíÔºâ',
        sel_practice: 'ÁªÉ‰π†Ê®°Âºè',
        sel_char_mode: 'Â≠óÁ¨¶Ê®°ÂºèÔºö',
        opt_all: 'ÂÖ®ÈÉ®',
        opt_hiragana_only: 'Âπ≥ÂÅáÂêç',
        opt_katakana_only: 'ÁâáÂÅáÂêç',
        sel_start: 'ÂºÄÂßãÊµãÈ™å',
        quiz_end: 'ÁªìÊùü',
        draw_clear: 'Ê∏ÖÈô§',
        draw_show: 'ÊòæÁ§∫Á≠îÊ°à',
        draw_wrong: 'ÈîôËØØ',
        draw_correct: 'Ê≠£Á°Æ',
        sum_title: 'Êú¨Ê¨°ÊµãÈ™åÊÄªÁªì',
        sum_memo_rule: 'ËßÑÂàôÔºöÂ±ïÁ§∫Ê¨°Êï∞‚â•3‰∏îÂπ≥ÂÅáÂêçÁâáÂÅáÂêçÂùáÂÖ®Ê≠£Á°ÆÊñπÂèØËÆ∞ÂøÜ',
        sum_newly_mem: 'Êñ∞ËÆ∞ÂøÜÁöÑÂ≠óÁ¨¶',
        sum_got_wrong: 'ÂõûÁ≠îÈîôËØØÁöÑÂ≠óÁ¨¶',
        th_romaji: 'ÁΩóÈ©¨Â≠ó',
        th_script: 'Â≠óÊØçÁ±ªÂûã',
        th_errors: 'ÈîôËØØÊï∞',
        sum_retry: 'ÂÜçÁªÉ‰∏ÄÊ¨°',
        sum_reselect: 'Êõ¥Êç¢ÈÄâÈ°π',
        prog_title: 'Â≠¶‰π†ËøõÂ∫¶',
        prog_back: '‚Üê ËøîÂõû',
        prog_struggling: 'ÈúÄÂä†Âº∫ÁªÉ‰π†',
        prog_inprogress: 'Â≠¶‰π†‰∏≠',
        prog_memorized: 'Â∑≤ËÆ∞ÂøÜ',
        prog_unseen: 'Êú™Êé•Ëß¶',
        alert_no_weak: 'ÊöÇÊó†ÈîôËØØÊï∞ÊçÆÔºåËØ∑ÂÖàÂÆåÊàê‰∏ÄÊ¨°ÊµãÈ™åÔºÅ',
        alert_reset_confirm: 'Á°ÆÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâËÆ∞ÂøÜÊï∞ÊçÆÂíåÈîôËØØËÆ∞ÂΩïÂêóÔºü',
        alert_reset_done: 'Êï∞ÊçÆÂ∑≤ÈáçÁΩÆ„ÄÇ',
        listen_label: 'ËØ∑ËÆ§ÁúüËÅÜÂê¨ÔºÅ',
        grp_vowels: 'ÊØçÈü≥',
        grp_k: 'KË°å',
        grp_s: 'SË°å',
        grp_t: 'TË°å',
        grp_n: 'NË°å',
        grp_h: 'HË°å',
        grp_m: 'MË°å',
        grp_y: 'YË°å',
        grp_r: 'RË°å',
        grp_w: 'WË°å / N',
        grp_g: 'GË°åÔºàÊµäÈü≥Ôºâ',
        grp_z: 'ZË°åÔºàÊµäÈü≥Ôºâ',
        grp_d: 'DË°åÔºàÊµäÈü≥Ôºâ',
        grp_b: 'BË°åÔºàÊµäÈü≥Ôºâ',
        grp_p: 'PË°åÔºàÂçäÊµäÈü≥Ôºâ',
        grp_con1: 'ÊãóÈü≥ÔºàK„ÄÅS„ÄÅT„ÄÅNË°åÔºâ',
        grp_con2: 'ÊãóÈü≥ÔºàH„ÄÅM„ÄÅRË°åÔºâ',
        grp_con3: 'ÊãóÈü≥ÊµäÈü≥',
        mode_type_kr: 'ÊâìÂ≠ó<br>(ÂÅáÂêç‚ÜíÁΩó)',
        mode_sel_kr: 'ÈÄâÊã©<br>(ÂÅáÂêç‚ÜíÁΩó)',
        mode_sel_hk: 'ÈÄâÊã©<br>(Âπ≥‚ÜîÁâá)',
        mode_sel_ak: 'ÈÄâÊã©<br>(üîä‚ÜíÂÅáÂêç)',
        mode_sel_rk: 'ÈÄâÊã©<br>(ÁΩó‚ÜíÂÅáÂêç)',
        mode_read_word: 'ËØªÂçïËØç<br>(ÊâìÂ≠ó)',
        mode_draw_rk: 'ÊâãÂÜô<br>(ÁΩó‚ÜíÂÅáÂêç)',
        mode_draw_hk: 'ÊâãÂÜô<br>(Âπ≥‚ÜîÁâá)',
        mode_draw_ak: 'ÊâãÂÜô<br>(üîä‚ÜíÂÅáÂêç)',
        lbl_hiragana: 'Âπ≥ÂÅáÂêç',
        lbl_katakana: 'ÁâáÂÅáÂêç',
        lbl_romaji: 'ÁΩóÈ©¨Â≠ó',
        lbl_audio: 'Èü≥È¢ë',
        alert_no_words: 'ÊâÄÈÄâÂÅáÂêç‰∏çË∂≥‰ª•ÁªÑÊàê‰ªª‰ΩïÂçïËØçÔºåËØ∑ÈÄâÊã©Êõ¥Â§öÁªÑÂà´ÔºÅ',
        sel_count_label: '‰∏™Â∑≤ÈÄâ',
        stat_questions: 'È¢òÁõÆÊï∞',
        stat_correct: 'Ê≠£Á°Æ',
        stat_incorrect: 'ÈîôËØØ',
        stat_distinct: '‰∏çÂêåÂ≠óÁ¨¶',
        stat_duration: 'Áî®Êó∂',
        stat_score: 'ÂæóÂàÜ',
      }
    };

    let currentLang = localStorage.getItem('kanaQuizLang') || 'en';

    function t(key) {
      return (TRANSLATIONS[currentLang] || TRANSLATIONS.en)[key] || TRANSLATIONS.en[key] || key;
    }

    function setLang(lang) {
      currentLang = lang;
      localStorage.setItem('kanaQuizLang', lang);
      document.getElementById('btn-lang').textContent = lang === 'en' ? 'EN' : '‰∏≠Êñá';
      document.querySelectorAll('[data-i18n]').forEach(el => {
        el.innerHTML = t(el.dataset.i18n);
      });
      // Update sel-count label
      updateSelCount();
    }

    function toggleLang() {
      setLang(currentLang === 'en' ? 'zh' : 'en');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    buildSelectionScreen();
    setLang(currentLang); // apply persisted language on load

    // Service Worker Registration
    if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(reg => console.log('SW registered!', reg))
          .catch(err => {
            if (err.message && err.message.includes('URL protocol')) return; // ignore local file:// execution error
            console.log('SW registration failed:', err);
          });
      });
    }
  </script>
</body>

</html>